(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[337],{2563:function(module){module.exports={vertex:"precision mediump float;\n\nattribute vec2 aPosition;\nattribute vec2 aLumaPosition;\nattribute vec2 aChromaPosition;\nvarying vec2 vLumaPosition;\nvarying vec2 vChromaPosition;\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vLumaPosition = aLumaPosition;\n    vChromaPosition = aChromaPosition;\n}\n",fragment:"// inspired by https://github.com/mbebenita/Broadway/blob/master/Player/canvas.js\n\nprecision mediump float;\n\nuniform sampler2D uTextureY;\nuniform sampler2D uTextureCb;\nuniform sampler2D uTextureCr;\nvarying vec2 vLumaPosition;\nvarying vec2 vChromaPosition;\nvoid main() {\n   // Y, Cb, and Cr planes are uploaded as ALPHA textures.\n   float fY = texture2D(uTextureY, vLumaPosition).w;\n   float fCb = texture2D(uTextureCb, vChromaPosition).w;\n   float fCr = texture2D(uTextureCr, vChromaPosition).w;\n\n   // Premultipy the Y...\n   float fYmul = fY * 1.1643828125;\n\n   // And convert that to RGB!\n   gl_FragColor = vec4(\n     fYmul + 1.59602734375 * fCr - 0.87078515625,\n     fYmul - 0.39176171875 * fCb - 0.81296875 * fCr + 0.52959375,\n     fYmul + 2.017234375   * fCb - 1.081390625,\n     1\n   );\n}\n",vertexStripe:"precision mediump float;\n\nattribute vec2 aPosition;\nattribute vec2 aTexturePosition;\nvarying vec2 vTexturePosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vTexturePosition = aTexturePosition;\n}\n",fragmentStripe:"// extra 'stripe' texture fiddling to work around IE 11's poor performance on gl.LUMINANCE and gl.ALPHA textures\n\nprecision mediump float;\n\nuniform sampler2D uStripe;\nuniform sampler2D uTexture;\nvarying vec2 vTexturePosition;\nvoid main() {\n   // Y, Cb, and Cr planes are mapped into a pseudo-RGBA texture\n   // so we can upload them without expanding the bytes on IE 11\n   // which doesn't allow LUMINANCE or ALPHA textures\n   // The stripe textures mark which channel to keep for each pixel.\n   // Each texture extraction will contain the relevant value in one\n   // channel only.\n\n   float fLuminance = dot(\n      texture2D(uStripe, vTexturePosition),\n      texture2D(uTexture, vTexturePosition)\n   );\n\n   gl_FragColor = vec4(0, 0, 0, fLuminance);\n}\n"}},3605:function(module){!function(){"use strict";function FrameSink(canvas,options){throw Error("abstract")}FrameSink.prototype.drawFrame=function(buffer){throw Error("abstract")},FrameSink.prototype.clear=function(){throw Error("abstract")},module.exports=FrameSink}()},2333:function(module,__unused_webpack_exports,__webpack_require__){!function(){"use strict";var FrameSink=__webpack_require__(3605),YCbCr=__webpack_require__(9098);function SoftwareFrameSink(canvas){var self1=this,ctx=canvas.getContext("2d"),imageData=null,resampleCanvas=null,resampleContext=null;return self1.drawFrame=function(buffer){var cropWidth,cropHeight,drawContext,format=buffer.format;(canvas.width!==format.displayWidth||canvas.height!==format.displayHeight)&&(canvas.width=format.displayWidth,canvas.height=format.displayHeight),(null===imageData||imageData.width!=format.width||imageData.height!=format.height)&&function(width,height){for(var data=(imageData=ctx.createImageData(width,height)).data,pixelCount=width*height*4,i=0;i<pixelCount;i+=4)data[i+3]=255}(format.width,format.height),YCbCr.convertYCbCr(buffer,imageData.data);var resample=format.cropWidth!=format.displayWidth||format.cropHeight!=format.displayHeight;resample?(resampleCanvas||(cropWidth=format.cropWidth,cropHeight=format.cropHeight,(resampleCanvas=document.createElement("canvas")).width=cropWidth,resampleCanvas.height=cropHeight,resampleContext=resampleCanvas.getContext("2d")),drawContext=resampleContext):drawContext=ctx,drawContext.putImageData(imageData,-format.cropLeft,-format.cropTop,format.cropLeft,format.cropTop,format.cropWidth,format.cropHeight),resample&&ctx.drawImage(resampleCanvas,0,0,format.displayWidth,format.displayHeight)},self1.clear=function(){ctx.clearRect(0,0,canvas.width,canvas.height)},self1}SoftwareFrameSink.prototype=Object.create(FrameSink.prototype),module.exports=SoftwareFrameSink}()},3935:function(module,__unused_webpack_exports,__webpack_require__){!function(){"use strict";var FrameSink=__webpack_require__(3605),shaders=__webpack_require__(2563);function WebGLFrameSink(canvas){var program,unpackProgram,buf,positionLocation,unpackTexturePositionBuffer,unpackTexturePositionLocation,stripeLocation,unpackTextureLocation,lumaPositionBuffer,lumaPositionLocation,chromaPositionBuffer,chromaPositionLocation,self1=this,gl=WebGLFrameSink.contextForCanvas(canvas);if(null===gl)throw Error("WebGL unavailable");function compileShader(type,source){var shader=gl.createShader(type);if(gl.shaderSource(shader,source),gl.compileShader(shader),!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){var err=gl.getShaderInfoLog(shader);throw gl.deleteShader(shader),Error("GL shader compilation for "+type+" failed: "+err)}return shader}var rectangle=new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),textures={},framebuffers={},stripes={};function createOrReuseTexture(name,formatUpdate){return(!textures[name]||formatUpdate)&&(textures[name]=gl.createTexture()),textures[name]}function uploadTexture(name,formatUpdate,width,height,data){var create=!textures[name]||formatUpdate,texture=createOrReuseTexture(name,formatUpdate);if(gl.activeTexture(gl.TEXTURE0),WebGLFrameSink.stripe){var uploadTemp=!textures[name+"_temp"]||formatUpdate,tempTexture=createOrReuseTexture(name+"_temp",formatUpdate);gl.bindTexture(gl.TEXTURE_2D,tempTexture),uploadTemp?(gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width/4,height,0,gl.RGBA,gl.UNSIGNED_BYTE,data)):gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,width/4,height,gl.RGBA,gl.UNSIGNED_BYTE,data);var stripeTexture=textures[name+"_stripe"],uploadStripe=!stripeTexture||formatUpdate;uploadStripe&&(stripeTexture=createOrReuseTexture(name+"_stripe",formatUpdate)),gl.bindTexture(gl.TEXTURE_2D,stripeTexture),uploadStripe&&(gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,1,0,gl.RGBA,gl.UNSIGNED_BYTE,function(width){if(stripes[width])return stripes[width];for(var out=new Uint32Array(width),i=0;i<width;i+=4)out[i]=255,out[i+1]=65280,out[i+2]=16711680,out[i+3]=4278190080;return stripes[width]=new Uint8Array(out.buffer)}(width,1)))}else gl.bindTexture(gl.TEXTURE_2D,texture),create?(gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR),gl.texImage2D(gl.TEXTURE_2D,0,gl.ALPHA,width,height,0,gl.ALPHA,gl.UNSIGNED_BYTE,data)):gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,width,height,gl.ALPHA,gl.UNSIGNED_BYTE,data)}function unpackTexture(name,formatUpdate,width,height){var texture=textures[name];gl.useProgram(unpackProgram);var fb=framebuffers[name];(!fb||formatUpdate)&&(gl.activeTexture(gl.TEXTURE0),gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null),fb=framebuffers[name]=gl.createFramebuffer()),gl.bindFramebuffer(gl.FRAMEBUFFER,fb),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);var tempTexture=textures[name+"_temp"];gl.activeTexture(gl.TEXTURE1),gl.bindTexture(gl.TEXTURE_2D,tempTexture),gl.uniform1i(unpackTextureLocation,1);var stripeTexture=textures[name+"_stripe"];gl.activeTexture(gl.TEXTURE2),gl.bindTexture(gl.TEXTURE_2D,stripeTexture),gl.uniform1i(stripeLocation,2),gl.bindBuffer(gl.ARRAY_BUFFER,buf),gl.enableVertexAttribArray(positionLocation),gl.vertexAttribPointer(positionLocation,2,gl.FLOAT,!1,0,0),gl.bindBuffer(gl.ARRAY_BUFFER,unpackTexturePositionBuffer),gl.enableVertexAttribArray(unpackTexturePositionLocation),gl.vertexAttribPointer(unpackTexturePositionLocation,2,gl.FLOAT,!1,0,0),gl.viewport(0,0,width,height),gl.drawArrays(gl.TRIANGLES,0,rectangle.length/2),gl.bindFramebuffer(gl.FRAMEBUFFER,null)}function attachTexture(name,register,index){gl.activeTexture(register),gl.bindTexture(gl.TEXTURE_2D,textures[name]),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR),gl.uniform1i(gl.getUniformLocation(program,name),index)}function initProgram(vertexShaderSource,fragmentShaderSource){var vertexShader=compileShader(gl.VERTEX_SHADER,vertexShaderSource),fragmentShader=compileShader(gl.FRAGMENT_SHADER,fragmentShaderSource),program=gl.createProgram();if(gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),!gl.getProgramParameter(program,gl.LINK_STATUS)){var err=gl.getProgramInfoLog(program);throw gl.deleteProgram(program),Error("GL program linking failed: "+err)}return program}return self1.drawFrame=function(buffer){var format=buffer.format,formatUpdate=!program||canvas.width!==format.displayWidth||canvas.height!==format.displayHeight;if(formatUpdate&&(canvas.width=format.displayWidth,canvas.height=format.displayHeight,self1.clear()),program||function(){if(WebGLFrameSink.stripe){unpackProgram=initProgram(shaders.vertexStripe,shaders.fragmentStripe),gl.getAttribLocation(unpackProgram,"aPosition"),unpackTexturePositionBuffer=gl.createBuffer();var textureRectangle=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);gl.bindBuffer(gl.ARRAY_BUFFER,unpackTexturePositionBuffer),gl.bufferData(gl.ARRAY_BUFFER,textureRectangle,gl.STATIC_DRAW),unpackTexturePositionLocation=gl.getAttribLocation(unpackProgram,"aTexturePosition"),stripeLocation=gl.getUniformLocation(unpackProgram,"uStripe"),unpackTextureLocation=gl.getUniformLocation(unpackProgram,"uTexture")}program=initProgram(shaders.vertex,shaders.fragment),buf=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,buf),gl.bufferData(gl.ARRAY_BUFFER,rectangle,gl.STATIC_DRAW),positionLocation=gl.getAttribLocation(program,"aPosition"),lumaPositionBuffer=gl.createBuffer(),lumaPositionLocation=gl.getAttribLocation(program,"aLumaPosition"),chromaPositionBuffer=gl.createBuffer(),chromaPositionLocation=gl.getAttribLocation(program,"aChromaPosition")}(),formatUpdate){var setupTexturePosition=function(buffer,location,texWidth){var textureX0=format.cropLeft/texWidth,textureX1=(format.cropLeft+format.cropWidth)/texWidth,textureY0=(format.cropTop+format.cropHeight)/format.height,textureY1=format.cropTop/format.height,textureRectangle=new Float32Array([textureX0,textureY0,textureX1,textureY0,textureX0,textureY1,textureX0,textureY1,textureX1,textureY0,textureX1,textureY1]);gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,textureRectangle,gl.STATIC_DRAW)};setupTexturePosition(lumaPositionBuffer,lumaPositionLocation,buffer.y.stride),setupTexturePosition(chromaPositionBuffer,chromaPositionLocation,buffer.u.stride*format.width/format.chromaWidth)}uploadTexture("uTextureY",formatUpdate,buffer.y.stride,format.height,buffer.y.bytes),uploadTexture("uTextureCb",formatUpdate,buffer.u.stride,format.chromaHeight,buffer.u.bytes),uploadTexture("uTextureCr",formatUpdate,buffer.v.stride,format.chromaHeight,buffer.v.bytes),WebGLFrameSink.stripe&&(unpackTexture("uTextureY",formatUpdate,buffer.y.stride,format.height),unpackTexture("uTextureCb",formatUpdate,buffer.u.stride,format.chromaHeight),unpackTexture("uTextureCr",formatUpdate,buffer.v.stride,format.chromaHeight)),gl.useProgram(program),gl.viewport(0,0,canvas.width,canvas.height),attachTexture("uTextureY",gl.TEXTURE0,0),attachTexture("uTextureCb",gl.TEXTURE1,1),attachTexture("uTextureCr",gl.TEXTURE2,2),gl.bindBuffer(gl.ARRAY_BUFFER,buf),gl.enableVertexAttribArray(positionLocation),gl.vertexAttribPointer(positionLocation,2,gl.FLOAT,!1,0,0),gl.bindBuffer(gl.ARRAY_BUFFER,lumaPositionBuffer),gl.enableVertexAttribArray(lumaPositionLocation),gl.vertexAttribPointer(lumaPositionLocation,2,gl.FLOAT,!1,0,0),gl.bindBuffer(gl.ARRAY_BUFFER,chromaPositionBuffer),gl.enableVertexAttribArray(chromaPositionLocation),gl.vertexAttribPointer(chromaPositionLocation,2,gl.FLOAT,!1,0,0),gl.drawArrays(gl.TRIANGLES,0,rectangle.length/2)},self1.clear=function(){gl.viewport(0,0,canvas.width,canvas.height),gl.clearColor(0,0,0,0),gl.clear(gl.COLOR_BUFFER_BIT)},self1.clear(),self1}WebGLFrameSink.stripe=!1,WebGLFrameSink.contextForCanvas=function(canvas){var options={preferLowPowerToHighPerformance:!0,powerPreference:"low-power",failIfMajorPerformanceCaveat:!0,preserveDrawingBuffer:!0};return canvas.getContext("webgl",options)||canvas.getContext("experimental-webgl",options)},WebGLFrameSink.isAvailable=function(){var gl,canvas=document.createElement("canvas");canvas.width=1,canvas.height=1;try{gl=WebGLFrameSink.contextForCanvas(canvas)}catch(e){return!1}if(!gl)return!1;var register=gl.TEXTURE0,texture=gl.createTexture(),data=new Uint8Array(16),texWidth=WebGLFrameSink.stripe?1:4,format=WebGLFrameSink.stripe?gl.RGBA:gl.ALPHA,filter=WebGLFrameSink.stripe?gl.NEAREST:gl.LINEAR;return gl.activeTexture(register),gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,filter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,filter),gl.texImage2D(gl.TEXTURE_2D,0,format,texWidth,4,0,format,gl.UNSIGNED_BYTE,data),!gl.getError()},WebGLFrameSink.prototype=Object.create(FrameSink.prototype),module.exports=WebGLFrameSink}()},9098:function(module,__unused_webpack_exports,__webpack_require__){var depower;depower=__webpack_require__(6117),module.exports={convertYCbCr:/**
	 * Basic YCbCr->RGB conversion
	 *
	 * @author Brion Vibber <brion@pobox.com>
	 * @copyright 2014-2019
	 * @license MIT-style
	 *
	 * @param {YUVFrame} buffer - input frame buffer
	 * @param {Uint8ClampedArray} output - array to draw RGBA into
	 * Assumes that the output array already has alpha channel set to opaque.
	 */ function(buffer,output){var width=0|buffer.format.width,height=0|buffer.format.height,hdec=0|depower(buffer.format.width/buffer.format.chromaWidth),vdec=0|depower(buffer.format.height/buffer.format.chromaHeight),bytesY=buffer.y.bytes,bytesCb=buffer.u.bytes,bytesCr=buffer.v.bytes,strideY=0|buffer.y.stride,strideCb=0|buffer.u.stride,strideCr=0|buffer.v.stride,outStride=width<<2,YPtr=0,Y0Ptr=0,Y1Ptr=0,CbPtr=0,CrPtr=0,outPtr=0,outPtr0=0,outPtr1=0,colorCb=0,colorCr=0,multY=0,multCrR=0,multCbCrG=0,multCbB=0,x=0,y=0,xdec=0,ydec=0;if(1==hdec&&1==vdec)for(y=0,outPtr0=0,outPtr1=outStride,ydec=0;y<height;y+=2){for(x=0,Y1Ptr=(Y0Ptr=y*strideY|0)+strideY|0,CbPtr=ydec*strideCb|0,CrPtr=ydec*strideCr|0;x<width;x+=2)colorCb=0|bytesCb[CbPtr++],multCrR=(409*(colorCr=0|bytesCr[CrPtr++])|0)-57088|0,multCbCrG=(100*colorCb|0)+(208*colorCr|0)-34816|0,multCbB=(516*colorCb|0)-70912|0,multY=298*bytesY[Y0Ptr++]|0,output[outPtr0]=multY+multCrR>>8,output[outPtr0+1]=multY-multCbCrG>>8,output[outPtr0+2]=multY+multCbB>>8,outPtr0+=4,multY=298*bytesY[Y0Ptr++]|0,output[outPtr0]=multY+multCrR>>8,output[outPtr0+1]=multY-multCbCrG>>8,output[outPtr0+2]=multY+multCbB>>8,outPtr0+=4,multY=298*bytesY[Y1Ptr++]|0,output[outPtr1]=multY+multCrR>>8,output[outPtr1+1]=multY-multCbCrG>>8,output[outPtr1+2]=multY+multCbB>>8,outPtr1+=4,multY=298*bytesY[Y1Ptr++]|0,output[outPtr1]=multY+multCrR>>8,output[outPtr1+1]=multY-multCbCrG>>8,output[outPtr1+2]=multY+multCbB>>8,outPtr1+=4;outPtr0+=outStride,outPtr1+=outStride,ydec++}else for(y=0,outPtr=0;y<height;y++)for(x=0,xdec=0,ydec=y>>vdec,YPtr=y*strideY|0,CbPtr=ydec*strideCb|0,CrPtr=ydec*strideCr|0;x<width;x++)colorCb=0|bytesCb[CbPtr+(xdec=x>>hdec)],multCrR=(409*(colorCr=0|bytesCr[CrPtr+xdec])|0)-57088|0,multCbCrG=(100*colorCb|0)+(208*colorCr|0)-34816|0,multCbB=(516*colorCb|0)-70912|0,multY=298*bytesY[YPtr++]|0,output[outPtr]=multY+multCrR>>8,output[outPtr+1]=multY-multCbCrG>>8,output[outPtr+2]=multY+multCbB>>8,outPtr+=4}}},6117:function(module){module.exports=/**
   * Convert a ratio into a bit-shift count; for instance a ratio of 2
   * becomes a bit-shift of 1, while a ratio of 1 is a bit-shift of 0.
   *
   * @author Brion Vibber <brion@pobox.com>
   * @copyright 2016
   * @license MIT-style
   *
   * @param {number} ratio - the integer ratio to convert.
   * @returns {number} - number of bits to shift to multiply/divide by the ratio.
   * @throws exception if given a non-power-of-two
   */ function(ratio){for(var shiftCount=0,n=ratio>>1;0!=n;)n>>=1,shiftCount++;if(ratio!==1<<shiftCount)throw"chroma plane dimensions must be power of 2 ratio to luma plane dimensions; got "+ratio;return shiftCount}},6337:function(module,__unused_webpack_exports,__webpack_require__){var FrameSink,SoftwareFrameSink,WebGLFrameSink;FrameSink=__webpack_require__(3605),SoftwareFrameSink=__webpack_require__(2333),WebGLFrameSink=__webpack_require__(3935),module.exports={FrameSink:FrameSink,SoftwareFrameSink:SoftwareFrameSink,WebGLFrameSink:WebGLFrameSink,attach:function(canvas,options){return("webGL"in(options=options||{})?options.webGL:WebGLFrameSink.isAvailable())?new WebGLFrameSink(canvas,options):new SoftwareFrameSink(canvas,options)}}}}]);
//# sourceMappingURL=337.f2543dfd4335a0fc.js.map