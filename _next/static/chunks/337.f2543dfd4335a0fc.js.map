{"version":3,"file":"static/chunks/337.f2543dfd4335a0fc.js","mappings":"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","sources":["webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/build/shaders.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/FrameSink.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/SoftwareFrameSink.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/WebGLFrameSink.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/YCbCr.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/depower.js","webpack://_N_E/../../common/temp/node_modules/.pnpm/yuv-canvas@1.2.11/node_modules/yuv-canvas/src/yuv-canvas.js","webpack://_N_E/<anon>"],"sourcesContent":["module.exports = {\n  vertex: \"precision mediump float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aLumaPosition;\\nattribute vec2 aChromaPosition;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vLumaPosition = aLumaPosition;\\n    vChromaPosition = aChromaPosition;\\n}\\n\",\n  fragment: \"// inspired by https://github.com/mbebenita/Broadway/blob/master/Player/canvas.js\\n\\nprecision mediump float;\\n\\nuniform sampler2D uTextureY;\\nuniform sampler2D uTextureCb;\\nuniform sampler2D uTextureCr;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are uploaded as ALPHA textures.\\n   float fY = texture2D(uTextureY, vLumaPosition).w;\\n   float fCb = texture2D(uTextureCb, vChromaPosition).w;\\n   float fCr = texture2D(uTextureCr, vChromaPosition).w;\\n\\n   // Premultipy the Y...\\n   float fYmul = fY * 1.1643828125;\\n\\n   // And convert that to RGB!\\n   gl_FragColor = vec4(\\n     fYmul + 1.59602734375 * fCr - 0.87078515625,\\n     fYmul - 0.39176171875 * fCb - 0.81296875 * fCr + 0.52959375,\\n     fYmul + 2.017234375   * fCb - 1.081390625,\\n     1\\n   );\\n}\\n\",\n  vertexStripe: \"precision mediump float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aTexturePosition;\\nvarying vec2 vTexturePosition;\\n\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vTexturePosition = aTexturePosition;\\n}\\n\",\n  fragmentStripe: \"// extra 'stripe' texture fiddling to work around IE 11's poor performance on gl.LUMINANCE and gl.ALPHA textures\\n\\nprecision mediump float;\\n\\nuniform sampler2D uStripe;\\nuniform sampler2D uTexture;\\nvarying vec2 vTexturePosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are mapped into a pseudo-RGBA texture\\n   // so we can upload them without expanding the bytes on IE 11\\n   // which doesn't allow LUMINANCE or ALPHA textures\\n   // The stripe textures mark which channel to keep for each pixel.\\n   // Each texture extraction will contain the relevant value in one\\n   // channel only.\\n\\n   float fLuminance = dot(\\n      texture2D(uStripe, vTexturePosition),\\n      texture2D(uTexture, vTexturePosition)\\n   );\\n\\n   gl_FragColor = vec4(0, 0, 0, fLuminance);\\n}\\n\"\n};\n","(function() {\n  \"use strict\";\n\n  /**\n   * Create a YUVCanvas and attach it to an HTML5 canvas element.\n   *\n   * This will take over the drawing context of the canvas and may turn\n   * it into a WebGL 3d canvas if possible. Do not attempt to use the\n   * drawing context directly after this.\n   *\n   * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n   * @param {YUVCanvasOptions} options - map of options\n   * @throws exception if WebGL requested but unavailable\n   * @constructor\n   * @abstract\n   */\n  function FrameSink(canvas, options) {\n    throw new Error('abstract');\n  }\n\n  /**\n   * Draw a single YUV frame on the underlying canvas, converting to RGB.\n   * If necessary the canvas will be resized to the optimal pixel size\n   * for the given buffer's format.\n   *\n   * @param {YUVBuffer} buffer - the YUV buffer to draw\n   * @see {@link https://www.npmjs.com/package/yuv-buffer|yuv-buffer} for format\n   */\n  FrameSink.prototype.drawFrame = function(buffer) {\n    throw new Error('abstract');\n  };\n\n  /**\n   * Clear the canvas using appropriate underlying 2d or 3d context.\n   */\n  FrameSink.prototype.clear = function() {\n    throw new Error('abstract');\n  };\n\n  module.exports = FrameSink;\n\n})();\n","/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = require('./FrameSink.js'),\n\t\tYCbCr = require('./YCbCr.js');\n\n\t/**\n\t * @param {HTMLCanvasElement} canvas - HTML canvas eledment to attach to\n\t * @constructor\n\t */\n\tfunction SoftwareFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tctx = canvas.getContext('2d'),\n\t\t\timageData = null,\n\t\t\tresampleCanvas = null,\n\t\t\tresampleContext = null;\n\n\n\n\t\tfunction initImageData(width, height) {\n\t\t\timageData = ctx.createImageData(width, height);\n\n\t\t\t// Prefill the alpha to opaque\n\t\t\tvar data = imageData.data,\n\t\t\t\tpixelCount = width * height * 4;\n\t\t\tfor (var i = 0; i < pixelCount; i += 4) {\n\t\t\t\tdata[i + 3] = 255;\n\t\t\t}\n\t\t}\n\n\t\tfunction initResampleCanvas(cropWidth, cropHeight) {\n\t\t\tresampleCanvas = document.createElement('canvas');\n\t\t\tresampleCanvas.width = cropWidth;\n\t\t\tresampleCanvas.height = cropHeight;\n\t\t\tresampleContext = resampleCanvas.getContext('2d');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame into the canvas.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object to draw\n\t\t */\n\t\tself.drawFrame = function drawFrame(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tif (canvas.width !== format.displayWidth || canvas.height !== format.displayHeight) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t}\n\n\t\t\tif (imageData === null ||\n\t\t\t\t\timageData.width != format.width ||\n\t\t\t\t\timageData.height != format.height) {\n\t\t\t\tinitImageData(format.width, format.height);\n\t\t\t}\n\n\t\t\t// YUV -> RGB over the entire encoded frame\n\t\t\tYCbCr.convertYCbCr(buffer, imageData.data);\n\n\t\t\tvar resample = (format.cropWidth != format.displayWidth || format.cropHeight != format.displayHeight);\n\t\t\tvar drawContext;\n\t\t\tif (resample) {\n\t\t\t\t// hack for non-square aspect-ratio\n\t\t\t\t// putImageData doesn't resample, so we have to draw in two steps.\n\t\t\t\tif (!resampleCanvas) {\n\t\t\t\t\tinitResampleCanvas(format.cropWidth, format.cropHeight);\n\t\t\t\t}\n\t\t\t\tdrawContext = resampleContext;\n\t\t\t} else {\n\t\t\t\tdrawContext = ctx;\n\t\t\t}\n\n\t\t\t// Draw cropped frame to either the final or temporary canvas\n\t\t\tdrawContext.putImageData(imageData,\n\t\t\t\t-format.cropLeft, -format.cropTop, // must offset the offset\n\t\t\t\tformat.cropLeft, format.cropTop,\n\t\t\t\tformat.cropWidth, format.cropHeight);\n\n\t\t\tif (resample) {\n\t\t\t\tctx.drawImage(resampleCanvas, 0, 0, format.displayWidth, format.displayHeight);\n\t\t\t}\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t};\n\n\t\treturn self;\n\t}\n\n\tSoftwareFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = SoftwareFrameSink;\n})();\n","/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = require('./FrameSink.js'),\n\t\tshaders = require('../build/shaders.js');\n\n\t/**\n\t * Warning: canvas must not have been used for 2d drawing prior!\n\t *\n\t * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n\t * @constructor\n\t */\n\tfunction WebGLFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas),\n\t\t\tdebug = false; // swap this to enable more error checks, which can slow down rendering\n\n\t\tif (gl === null) {\n\t\t\tthrow new Error('WebGL unavailable');\n\t\t}\n\n\t\t// GL!\n\t\tfunction checkError() {\n\t\t\tif (debug) {\n\t\t\t\terr = gl.getError();\n\t\t\t\tif (err !== 0) {\n\t\t\t\t\tthrow new Error(\"GL error \" + err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction compileShader(type, source) {\n\t\t\tvar shader = gl.createShader(type);\n\t\t\tgl.shaderSource(shader, source);\n\t\t\tgl.compileShader(shader);\n\n\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\t\t\tvar err = gl.getShaderInfoLog(shader);\n\t\t\t\tgl.deleteShader(shader);\n\t\t\t\tthrow new Error('GL shader compilation for ' + type + ' failed: ' + err);\n\t\t\t}\n\n\t\t\treturn shader;\n\t\t}\n\n\n\t\tvar program,\n\t\t\tunpackProgram,\n\t\t\terr;\n\n\t\t// In the world of GL there are no rectangles.\n\t\t// There are only triangles.\n\t\t// THERE IS NO SPOON.\n\t\tvar rectangle = new Float32Array([\n\t\t\t// First triangle (top left, clockwise)\n\t\t\t-1.0, -1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t-1.0, +1.0,\n\n\t\t\t// Second triangle (bottom right, clockwise)\n\t\t\t-1.0, +1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t+1.0, +1.0\n\t\t]);\n\n\t\tvar textures = {};\n\t\tvar framebuffers = {};\n\t\tvar stripes = {};\n\t\tvar buf, positionLocation, unpackPositionLocation;\n\t\tvar unpackTexturePositionBuffer, unpackTexturePositionLocation;\n\t\tvar stripeLocation, unpackTextureLocation;\n\t\tvar lumaPositionBuffer, lumaPositionLocation;\n\t\tvar chromaPositionBuffer, chromaPositionLocation;\n\n\t\tfunction createOrReuseTexture(name, formatUpdate) {\n\t\t\tif (!textures[name] || formatUpdate) {\n\t\t\t\ttextures[name] = gl.createTexture();\n\t\t\t}\n\t\t\treturn textures[name];\n\t\t}\n\n\t\tfunction uploadTexture(name, formatUpdate, width, height, data) {\n\t\t\tvar create = !textures[name] || formatUpdate;\n\t\t\tvar texture = createOrReuseTexture(name, formatUpdate);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tvar uploadTemp = !textures[name + '_temp'] || formatUpdate;\n\t\t\t\tvar tempTexture = createOrReuseTexture(name + '_temp', formatUpdate);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\t\tif (uploadTemp) {\n\t\t\t\t\t// new texture\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// update texture\n\t\t\t\t\tgl.texSubImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\t0, // x offset\n\t\t\t\t\t\t0, // y offset\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\t\tvar uploadStripe = !stripeTexture || formatUpdate;\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tstripeTexture = createOrReuseTexture(name + '_stripe', formatUpdate);\n\t\t\t\t}\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tbuildStripe(width, 1) // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tif (create) {\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.ALPHA, // internal format\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.ALPHA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tgl.texSubImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\t0, // x\n\t\t\t\t\t\t0, // y\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tgl.ALPHA, // internal format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction unpackTexture(name, formatUpdate, width, height) {\n\t\t\tvar texture = textures[name];\n\n\t\t\t// Upload to a temporary RGBA texture, then unpack it.\n\t\t\t// This is faster than CPU-side swizzling in ANGLE on Windows.\n\t\t\tgl.useProgram(unpackProgram);\n\n\t\t\tvar fb = framebuffers[name];\n\t\t\tif (!fb || formatUpdate) {\n\t\t\t\t// Create a framebuffer and an empty target size\n\t\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\tgl.texImage2D(\n\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t0, // mip level\n\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\t0, // border\n\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\tnull // data!\n\t\t\t\t);\n\n\t\t\t\tfb = framebuffers[name] = gl.createFramebuffer();\n\t\t\t}\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\t\t\tvar tempTexture = textures[name + '_temp'];\n\t\t\tgl.activeTexture(gl.TEXTURE1);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\tgl.uniform1i(unpackTextureLocation, 1);\n\n\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\tgl.activeTexture(gl.TEXTURE2);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\tgl.uniform1i(stripeLocation, 2);\n\n\t\t\t// Rectangle geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\tgl.enableVertexAttribArray(unpackTexturePositionLocation);\n\t\t\tgl.vertexAttribPointer(unpackTexturePositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Draw into the target texture...\n\t\t\tgl.viewport(0, 0, width, height);\n\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t}\n\n\t\tfunction attachTexture(name, register, index) {\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, textures[name]);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n\t\t\tgl.uniform1i(gl.getUniformLocation(program, name), index);\n\t\t}\n\n\t\tfunction buildStripe(width) {\n\t\t\tif (stripes[width]) {\n\t\t\t\treturn stripes[width];\n\t\t\t}\n\t\t\tvar len = width,\n\t\t\t\tout = new Uint32Array(len);\n\t\t\tfor (var i = 0; i < len; i += 4) {\n\t\t\t\tout[i    ] = 0x000000ff;\n\t\t\t\tout[i + 1] = 0x0000ff00;\n\t\t\t\tout[i + 2] = 0x00ff0000;\n\t\t\t\tout[i + 3] = 0xff000000;\n\t\t\t}\n\t\t\treturn stripes[width] = new Uint8Array(out.buffer);\n\t\t}\n\n\t\tfunction initProgram(vertexShaderSource, fragmentShaderSource) {\n\t\t\tvar vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n\t\t\tvar fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n\t\t\tvar program = gl.createProgram();\n\t\t\tgl.attachShader(program, vertexShader);\n\t\t\tgl.attachShader(program, fragmentShader);\n\n\t\t\tgl.linkProgram(program);\n\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\t\tvar err = gl.getProgramInfoLog(program);\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\tthrow new Error('GL program linking failed: ' + err);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction init() {\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tunpackProgram = initProgram(shaders.vertexStripe, shaders.fragmentStripe);\n\t\t\t\tunpackPositionLocation = gl.getAttribLocation(unpackProgram, 'aPosition');\n\n\t\t\t\tunpackTexturePositionBuffer = gl.createBuffer();\n\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t0, 0,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t1, 1\n\t\t\t\t]);\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\n\t\t\t\tunpackTexturePositionLocation = gl.getAttribLocation(unpackProgram, 'aTexturePosition');\n\t\t\t\tstripeLocation = gl.getUniformLocation(unpackProgram, 'uStripe');\n\t\t\t\tunpackTextureLocation = gl.getUniformLocation(unpackProgram, 'uTexture');\n\t\t\t}\n\t\t\tprogram = initProgram(shaders.vertex, shaders.fragment);\n\n\t\t\tbuf = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, rectangle, gl.STATIC_DRAW);\n\n\t\t\tpositionLocation = gl.getAttribLocation(program, 'aPosition');\n\t\t\tlumaPositionBuffer = gl.createBuffer();\n\t\t\tlumaPositionLocation = gl.getAttribLocation(program, 'aLumaPosition');\n\t\t\tchromaPositionBuffer = gl.createBuffer();\n\t\t\tchromaPositionLocation = gl.getAttribLocation(program, 'aChromaPosition');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object\n\t\t */\n\t\tself.drawFrame = function(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tvar formatUpdate = (!program || canvas.width !== format.displayWidth || canvas.height !== format.displayHeight);\n\t\t\tif (formatUpdate) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t\tself.clear();\n\t\t\t}\n\n\t\t\tif (!program) {\n\t\t\t\tinit();\n\t\t\t}\n\n\t\t\tif (formatUpdate) {\n\t\t\t\tvar setupTexturePosition = function(buffer, location, texWidth) {\n\t\t\t\t\t// Warning: assumes that the stride for Cb and Cr is the same size in output pixels\n\t\t\t\t\tvar textureX0 = format.cropLeft / texWidth;\n\t\t\t\t\tvar textureX1 = (format.cropLeft + format.cropWidth) / texWidth;\n\t\t\t\t\tvar textureY0 = (format.cropTop + format.cropHeight) / format.height;\n\t\t\t\t\tvar textureY1 = format.cropTop / format.height;\n\t\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t\ttextureX0, textureY0,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX1, textureY1\n\t\t\t\t\t]);\n\n\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\t\t\t\t};\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tlumaPositionBuffer,\n\t\t\t\t\tlumaPositionLocation,\n\t\t\t\t\tbuffer.y.stride);\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tchromaPositionBuffer,\n\t\t\t\t\tchromaPositionLocation,\n\t\t\t\t\tbuffer.u.stride * format.width / format.chromaWidth);\n\t\t\t}\n\n\t\t\t// Create or update the textures...\n\t\t\tuploadTexture('uTextureY', formatUpdate, buffer.y.stride, format.height, buffer.y.bytes);\n\t\t\tuploadTexture('uTextureCb', formatUpdate, buffer.u.stride, format.chromaHeight, buffer.u.bytes);\n\t\t\tuploadTexture('uTextureCr', formatUpdate, buffer.v.stride, format.chromaHeight, buffer.v.bytes);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\t// Unpack the textures after upload to avoid blocking on GPU\n\t\t\t\tunpackTexture('uTextureY', formatUpdate, buffer.y.stride, format.height);\n\t\t\t\tunpackTexture('uTextureCb', formatUpdate, buffer.u.stride, format.chromaHeight);\n\t\t\t\tunpackTexture('uTextureCr', formatUpdate, buffer.v.stride, format.chromaHeight);\n\t\t\t}\n\n\t\t\t// Set up the rectangle and draw it\n\t\t\tgl.useProgram(program);\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\n\t\t\tattachTexture('uTextureY', gl.TEXTURE0, 0);\n\t\t\tattachTexture('uTextureCb', gl.TEXTURE1, 1);\n\t\t\tattachTexture('uTextureCr', gl.TEXTURE2, 2);\n\n\t\t\t// Set up geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, lumaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(lumaPositionLocation);\n\t\t\tgl.vertexAttribPointer(lumaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, chromaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(chromaPositionLocation);\n\t\t\tgl.vertexAttribPointer(chromaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Aaaaand draw stuff.\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\t\t\tgl.clearColor(0.0, 0.0, 0.0, 0.0);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t};\n\n\t\tself.clear();\n\n\t\treturn self;\n\t}\n\n\t// Optional performance hack for Windows; luminance and alpha textures are\n\t// ssllooww to upload on some machines, so we pack into RGBA and unpack in\n\t// the shaders.\n\t//\n\t// Some browsers / GPUs seem to have no problem with this, others have\n\t// a huge impact in CPU doing the texture uploads.\n\t//\n\t// For instance on macOS 12.2 on a MacBook Pro 2018 with AMD GPU it\n\t// can real down at high res. This is partially compensated for by\n\t// improving the upload-vs-update behavior for the alpha textures.\n\t//\n\t// Currently keeping it off as of April 2022, but leaving it in so it\n\t// can be enabled if desired.\n\tWebGLFrameSink.stripe = false;\n\n\tWebGLFrameSink.contextForCanvas = function(canvas) {\n\t\tvar options = {\n\t\t\t// Don't trigger discrete GPU in multi-GPU systems\n\t\t\tpreferLowPowerToHighPerformance: true,\n\t\t\tpowerPreference: 'low-power',\n\t\t\t// Don't try to use software GL rendering!\n\t\t\tfailIfMajorPerformanceCaveat: true,\n\t\t\t// In case we need to capture the resulting output.\n\t\t\tpreserveDrawingBuffer: true\n\t\t};\n\t\treturn canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);\n\t};\n\n\t/**\n\t * Static function to check if WebGL will be available with appropriate features.\n\t *\n\t * @returns {boolean} - true if available\n\t */\n\tWebGLFrameSink.isAvailable = function() {\n\t\tvar canvas = document.createElement('canvas'),\n\t\t\tgl;\n\t\tcanvas.width = 1;\n\t\tcanvas.height = 1;\n\t\ttry {\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (gl) {\n\t\t\tvar register = gl.TEXTURE0,\n\t\t\t\twidth = 4,\n\t\t\t\theight = 4,\n\t\t\t\ttexture = gl.createTexture(),\n\t\t\t\tdata = new Uint8Array(width * height),\n\t\t\t\ttexWidth = WebGLFrameSink.stripe ? (width / 4) : width,\n\t\t\t\tformat = WebGLFrameSink.stripe ? gl.RGBA : gl.ALPHA,\n\t\t\t\tfilter = WebGLFrameSink.stripe ? gl.NEAREST : gl.LINEAR;\n\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n\t\t\tgl.texImage2D(\n\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t0, // mip level\n\t\t\t\tformat, // internal format\n\t\t\t\ttexWidth,\n\t\t\t\theight,\n\t\t\t\t0, // border\n\t\t\t\tformat, // format\n\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\tdata // data!\n\t\t\t);\n\n\t\t\tvar err = gl.getError();\n\t\t\tif (err) {\n\t\t\t\t// Doesn't support alpha textures?\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tWebGLFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = WebGLFrameSink;\n})();\n","/*\nCopyright (c) 2014-2019 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar depower = require('./depower.js');\n\n\t/**\n\t * Basic YCbCr->RGB conversion\n\t *\n\t * @author Brion Vibber <brion@pobox.com>\n\t * @copyright 2014-2019\n\t * @license MIT-style\n\t *\n\t * @param {YUVFrame} buffer - input frame buffer\n\t * @param {Uint8ClampedArray} output - array to draw RGBA into\n\t * Assumes that the output array already has alpha channel set to opaque.\n\t */\n\tfunction convertYCbCr(buffer, output) {\n\t\tvar width = buffer.format.width | 0,\n\t\t\theight = buffer.format.height | 0,\n\t\t\thdec = depower(buffer.format.width / buffer.format.chromaWidth) | 0,\n\t\t\tvdec = depower(buffer.format.height / buffer.format.chromaHeight) | 0,\n\t\t\tbytesY = buffer.y.bytes,\n\t\t\tbytesCb = buffer.u.bytes,\n\t\t\tbytesCr = buffer.v.bytes,\n\t\t\tstrideY = buffer.y.stride | 0,\n\t\t\tstrideCb = buffer.u.stride | 0,\n\t\t\tstrideCr = buffer.v.stride | 0,\n\t\t\toutStride = width << 2,\n\t\t\tYPtr = 0, Y0Ptr = 0, Y1Ptr = 0,\n\t\t\tCbPtr = 0, CrPtr = 0,\n\t\t\toutPtr = 0, outPtr0 = 0, outPtr1 = 0,\n\t\t\tcolorCb = 0, colorCr = 0,\n\t\t\tmultY = 0, multCrR = 0, multCbCrG = 0, multCbB = 0,\n\t\t\tx = 0, y = 0, xdec = 0, ydec = 0;\n\n\t\tif (hdec == 1 && vdec == 1) {\n\t\t\t// Optimize for 4:2:0, which is most common\n\t\t\toutPtr0 = 0;\n\t\t\toutPtr1 = outStride;\n\t\t\tydec = 0;\n\t\t\tfor (y = 0; y < height; y += 2) {\n\t\t\t\tY0Ptr = y * strideY | 0;\n\t\t\t\tY1Ptr = Y0Ptr + strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\t\t\t\tfor (x = 0; x < width; x += 2) {\n\t\t\t\t\tcolorCb = bytesCb[CbPtr++] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr++] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\t\t\t\t}\n\t\t\t\toutPtr0 += outStride;\n\t\t\t\toutPtr1 += outStride;\n\t\t\t\tydec++;\n\t\t\t}\n\t\t} else {\n\t\t\toutPtr = 0;\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\txdec = 0;\n\t\t\t\tydec = y >> vdec;\n\t\t\t\tYPtr = y * strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\txdec = x >> hdec;\n\t\t\t\t\tcolorCb = bytesCb[CbPtr + xdec] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr + xdec] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[YPtr++] | 0;\n\t\t\t\t\toutput[outPtr    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmodule.exports = {\n\t\tconvertYCbCr: convertYCbCr\n\t};\n})();\n","/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  /**\n   * Convert a ratio into a bit-shift count; for instance a ratio of 2\n   * becomes a bit-shift of 1, while a ratio of 1 is a bit-shift of 0.\n   *\n   * @author Brion Vibber <brion@pobox.com>\n   * @copyright 2016\n   * @license MIT-style\n   *\n   * @param {number} ratio - the integer ratio to convert.\n   * @returns {number} - number of bits to shift to multiply/divide by the ratio.\n   * @throws exception if given a non-power-of-two\n   */\n  function depower(ratio) {\n    var shiftCount = 0,\n      n = ratio >> 1;\n    while (n != 0) {\n      n = n >> 1;\n      shiftCount++\n    }\n    if (ratio !== (1 << shiftCount)) {\n      throw 'chroma plane dimensions must be power of 2 ratio to luma plane dimensions; got ' + ratio;\n    }\n    return shiftCount;\n  }\n\n  module.exports = depower;\n})();\n","/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  var FrameSink = require('./FrameSink.js'),\n    SoftwareFrameSink = require('./SoftwareFrameSink.js'),\n    WebGLFrameSink = require('./WebGLFrameSink.js');\n\n  /**\n   * @typedef {Object} YUVCanvasOptions\n   * @property {boolean} webGL - Whether to use WebGL to draw to the canvas and accelerate color space conversion. If left out, defaults to auto-detect.\n   */\n\n  var YUVCanvas = {\n    FrameSink: FrameSink,\n\n    SoftwareFrameSink: SoftwareFrameSink,\n\n    WebGLFrameSink: WebGLFrameSink,\n\n    /**\n     * Attach a suitable FrameSink instance to an HTML5 canvas element.\n     *\n     * This will take over the drawing context of the canvas and may turn\n     * it into a WebGL 3d canvas if possible. Do not attempt to use the\n     * drawing context directly after this.\n     *\n     * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n     * @param {YUVCanvasOptions} options - map of options\n     * @returns {FrameSink} - instance of suitable subclass.\n     */\n    attach: function(canvas, options) {\n      options = options || {};\n      var webGL = ('webGL' in options) ? options.webGL : WebGLFrameSink.isAvailable();\n      if (webGL) {\n        return new WebGLFrameSink(canvas, options);\n      } else {\n        return new SoftwareFrameSink(canvas, options);\n      }\n    }\n  };\n\n  module.exports = YUVCanvas;\n})();\n","(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[337],{\n\n/***/ 2563:\n/***/ (function(module) {\n\nmodule.exports = {\n  vertex: \"precision mediump float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aLumaPosition;\\nattribute vec2 aChromaPosition;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vLumaPosition = aLumaPosition;\\n    vChromaPosition = aChromaPosition;\\n}\\n\",\n  fragment: \"// inspired by https://github.com/mbebenita/Broadway/blob/master/Player/canvas.js\\n\\nprecision mediump float;\\n\\nuniform sampler2D uTextureY;\\nuniform sampler2D uTextureCb;\\nuniform sampler2D uTextureCr;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are uploaded as ALPHA textures.\\n   float fY = texture2D(uTextureY, vLumaPosition).w;\\n   float fCb = texture2D(uTextureCb, vChromaPosition).w;\\n   float fCr = texture2D(uTextureCr, vChromaPosition).w;\\n\\n   // Premultipy the Y...\\n   float fYmul = fY * 1.1643828125;\\n\\n   // And convert that to RGB!\\n   gl_FragColor = vec4(\\n     fYmul + 1.59602734375 * fCr - 0.87078515625,\\n     fYmul - 0.39176171875 * fCb - 0.81296875 * fCr + 0.52959375,\\n     fYmul + 2.017234375   * fCb - 1.081390625,\\n     1\\n   );\\n}\\n\",\n  vertexStripe: \"precision mediump float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aTexturePosition;\\nvarying vec2 vTexturePosition;\\n\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vTexturePosition = aTexturePosition;\\n}\\n\",\n  fragmentStripe: \"// extra 'stripe' texture fiddling to work around IE 11's poor performance on gl.LUMINANCE and gl.ALPHA textures\\n\\nprecision mediump float;\\n\\nuniform sampler2D uStripe;\\nuniform sampler2D uTexture;\\nvarying vec2 vTexturePosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are mapped into a pseudo-RGBA texture\\n   // so we can upload them without expanding the bytes on IE 11\\n   // which doesn't allow LUMINANCE or ALPHA textures\\n   // The stripe textures mark which channel to keep for each pixel.\\n   // Each texture extraction will contain the relevant value in one\\n   // channel only.\\n\\n   float fLuminance = dot(\\n      texture2D(uStripe, vTexturePosition),\\n      texture2D(uTexture, vTexturePosition)\\n   );\\n\\n   gl_FragColor = vec4(0, 0, 0, fLuminance);\\n}\\n\"\n};\n\n\n/***/ }),\n\n/***/ 3605:\n/***/ (function(module) {\n\n(function() {\n  \"use strict\";\n\n  /**\n   * Create a YUVCanvas and attach it to an HTML5 canvas element.\n   *\n   * This will take over the drawing context of the canvas and may turn\n   * it into a WebGL 3d canvas if possible. Do not attempt to use the\n   * drawing context directly after this.\n   *\n   * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n   * @param {YUVCanvasOptions} options - map of options\n   * @throws exception if WebGL requested but unavailable\n   * @constructor\n   * @abstract\n   */\n  function FrameSink(canvas, options) {\n    throw new Error('abstract');\n  }\n\n  /**\n   * Draw a single YUV frame on the underlying canvas, converting to RGB.\n   * If necessary the canvas will be resized to the optimal pixel size\n   * for the given buffer's format.\n   *\n   * @param {YUVBuffer} buffer - the YUV buffer to draw\n   * @see {@link https://www.npmjs.com/package/yuv-buffer|yuv-buffer} for format\n   */\n  FrameSink.prototype.drawFrame = function(buffer) {\n    throw new Error('abstract');\n  };\n\n  /**\n   * Clear the canvas using appropriate underlying 2d or 3d context.\n   */\n  FrameSink.prototype.clear = function() {\n    throw new Error('abstract');\n  };\n\n  module.exports = FrameSink;\n\n})();\n\n\n/***/ }),\n\n/***/ 2333:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = __webpack_require__(3605),\n\t\tYCbCr = __webpack_require__(9098);\n\n\t/**\n\t * @param {HTMLCanvasElement} canvas - HTML canvas eledment to attach to\n\t * @constructor\n\t */\n\tfunction SoftwareFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tctx = canvas.getContext('2d'),\n\t\t\timageData = null,\n\t\t\tresampleCanvas = null,\n\t\t\tresampleContext = null;\n\n\n\n\t\tfunction initImageData(width, height) {\n\t\t\timageData = ctx.createImageData(width, height);\n\n\t\t\t// Prefill the alpha to opaque\n\t\t\tvar data = imageData.data,\n\t\t\t\tpixelCount = width * height * 4;\n\t\t\tfor (var i = 0; i < pixelCount; i += 4) {\n\t\t\t\tdata[i + 3] = 255;\n\t\t\t}\n\t\t}\n\n\t\tfunction initResampleCanvas(cropWidth, cropHeight) {\n\t\t\tresampleCanvas = document.createElement('canvas');\n\t\t\tresampleCanvas.width = cropWidth;\n\t\t\tresampleCanvas.height = cropHeight;\n\t\t\tresampleContext = resampleCanvas.getContext('2d');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame into the canvas.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object to draw\n\t\t */\n\t\tself.drawFrame = function drawFrame(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tif (canvas.width !== format.displayWidth || canvas.height !== format.displayHeight) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t}\n\n\t\t\tif (imageData === null ||\n\t\t\t\t\timageData.width != format.width ||\n\t\t\t\t\timageData.height != format.height) {\n\t\t\t\tinitImageData(format.width, format.height);\n\t\t\t}\n\n\t\t\t// YUV -> RGB over the entire encoded frame\n\t\t\tYCbCr.convertYCbCr(buffer, imageData.data);\n\n\t\t\tvar resample = (format.cropWidth != format.displayWidth || format.cropHeight != format.displayHeight);\n\t\t\tvar drawContext;\n\t\t\tif (resample) {\n\t\t\t\t// hack for non-square aspect-ratio\n\t\t\t\t// putImageData doesn't resample, so we have to draw in two steps.\n\t\t\t\tif (!resampleCanvas) {\n\t\t\t\t\tinitResampleCanvas(format.cropWidth, format.cropHeight);\n\t\t\t\t}\n\t\t\t\tdrawContext = resampleContext;\n\t\t\t} else {\n\t\t\t\tdrawContext = ctx;\n\t\t\t}\n\n\t\t\t// Draw cropped frame to either the final or temporary canvas\n\t\t\tdrawContext.putImageData(imageData,\n\t\t\t\t-format.cropLeft, -format.cropTop, // must offset the offset\n\t\t\t\tformat.cropLeft, format.cropTop,\n\t\t\t\tformat.cropWidth, format.cropHeight);\n\n\t\t\tif (resample) {\n\t\t\t\tctx.drawImage(resampleCanvas, 0, 0, format.displayWidth, format.displayHeight);\n\t\t\t}\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t};\n\n\t\treturn self;\n\t}\n\n\tSoftwareFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = SoftwareFrameSink;\n})();\n\n\n/***/ }),\n\n/***/ 3935:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = __webpack_require__(3605),\n\t\tshaders = __webpack_require__(2563);\n\n\t/**\n\t * Warning: canvas must not have been used for 2d drawing prior!\n\t *\n\t * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n\t * @constructor\n\t */\n\tfunction WebGLFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas),\n\t\t\tdebug = false; // swap this to enable more error checks, which can slow down rendering\n\n\t\tif (gl === null) {\n\t\t\tthrow new Error('WebGL unavailable');\n\t\t}\n\n\t\t// GL!\n\t\tfunction checkError() {\n\t\t\tif (debug) {\n\t\t\t\terr = gl.getError();\n\t\t\t\tif (err !== 0) {\n\t\t\t\t\tthrow new Error(\"GL error \" + err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction compileShader(type, source) {\n\t\t\tvar shader = gl.createShader(type);\n\t\t\tgl.shaderSource(shader, source);\n\t\t\tgl.compileShader(shader);\n\n\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\t\t\tvar err = gl.getShaderInfoLog(shader);\n\t\t\t\tgl.deleteShader(shader);\n\t\t\t\tthrow new Error('GL shader compilation for ' + type + ' failed: ' + err);\n\t\t\t}\n\n\t\t\treturn shader;\n\t\t}\n\n\n\t\tvar program,\n\t\t\tunpackProgram,\n\t\t\terr;\n\n\t\t// In the world of GL there are no rectangles.\n\t\t// There are only triangles.\n\t\t// THERE IS NO SPOON.\n\t\tvar rectangle = new Float32Array([\n\t\t\t// First triangle (top left, clockwise)\n\t\t\t-1.0, -1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t-1.0, +1.0,\n\n\t\t\t// Second triangle (bottom right, clockwise)\n\t\t\t-1.0, +1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t+1.0, +1.0\n\t\t]);\n\n\t\tvar textures = {};\n\t\tvar framebuffers = {};\n\t\tvar stripes = {};\n\t\tvar buf, positionLocation, unpackPositionLocation;\n\t\tvar unpackTexturePositionBuffer, unpackTexturePositionLocation;\n\t\tvar stripeLocation, unpackTextureLocation;\n\t\tvar lumaPositionBuffer, lumaPositionLocation;\n\t\tvar chromaPositionBuffer, chromaPositionLocation;\n\n\t\tfunction createOrReuseTexture(name, formatUpdate) {\n\t\t\tif (!textures[name] || formatUpdate) {\n\t\t\t\ttextures[name] = gl.createTexture();\n\t\t\t}\n\t\t\treturn textures[name];\n\t\t}\n\n\t\tfunction uploadTexture(name, formatUpdate, width, height, data) {\n\t\t\tvar create = !textures[name] || formatUpdate;\n\t\t\tvar texture = createOrReuseTexture(name, formatUpdate);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tvar uploadTemp = !textures[name + '_temp'] || formatUpdate;\n\t\t\t\tvar tempTexture = createOrReuseTexture(name + '_temp', formatUpdate);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\t\tif (uploadTemp) {\n\t\t\t\t\t// new texture\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// update texture\n\t\t\t\t\tgl.texSubImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\t0, // x offset\n\t\t\t\t\t\t0, // y offset\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\t\tvar uploadStripe = !stripeTexture || formatUpdate;\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tstripeTexture = createOrReuseTexture(name + '_stripe', formatUpdate);\n\t\t\t\t}\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tbuildStripe(width, 1) // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tif (create) {\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.ALPHA, // internal format\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.ALPHA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tgl.texSubImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\t0, // x\n\t\t\t\t\t\t0, // y\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tgl.ALPHA, // internal format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction unpackTexture(name, formatUpdate, width, height) {\n\t\t\tvar texture = textures[name];\n\n\t\t\t// Upload to a temporary RGBA texture, then unpack it.\n\t\t\t// This is faster than CPU-side swizzling in ANGLE on Windows.\n\t\t\tgl.useProgram(unpackProgram);\n\n\t\t\tvar fb = framebuffers[name];\n\t\t\tif (!fb || formatUpdate) {\n\t\t\t\t// Create a framebuffer and an empty target size\n\t\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\tgl.texImage2D(\n\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t0, // mip level\n\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\t0, // border\n\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\tnull // data!\n\t\t\t\t);\n\n\t\t\t\tfb = framebuffers[name] = gl.createFramebuffer();\n\t\t\t}\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\t\t\tvar tempTexture = textures[name + '_temp'];\n\t\t\tgl.activeTexture(gl.TEXTURE1);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\tgl.uniform1i(unpackTextureLocation, 1);\n\n\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\tgl.activeTexture(gl.TEXTURE2);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\tgl.uniform1i(stripeLocation, 2);\n\n\t\t\t// Rectangle geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\tgl.enableVertexAttribArray(unpackTexturePositionLocation);\n\t\t\tgl.vertexAttribPointer(unpackTexturePositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Draw into the target texture...\n\t\t\tgl.viewport(0, 0, width, height);\n\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t}\n\n\t\tfunction attachTexture(name, register, index) {\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, textures[name]);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n\t\t\tgl.uniform1i(gl.getUniformLocation(program, name), index);\n\t\t}\n\n\t\tfunction buildStripe(width) {\n\t\t\tif (stripes[width]) {\n\t\t\t\treturn stripes[width];\n\t\t\t}\n\t\t\tvar len = width,\n\t\t\t\tout = new Uint32Array(len);\n\t\t\tfor (var i = 0; i < len; i += 4) {\n\t\t\t\tout[i    ] = 0x000000ff;\n\t\t\t\tout[i + 1] = 0x0000ff00;\n\t\t\t\tout[i + 2] = 0x00ff0000;\n\t\t\t\tout[i + 3] = 0xff000000;\n\t\t\t}\n\t\t\treturn stripes[width] = new Uint8Array(out.buffer);\n\t\t}\n\n\t\tfunction initProgram(vertexShaderSource, fragmentShaderSource) {\n\t\t\tvar vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n\t\t\tvar fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n\t\t\tvar program = gl.createProgram();\n\t\t\tgl.attachShader(program, vertexShader);\n\t\t\tgl.attachShader(program, fragmentShader);\n\n\t\t\tgl.linkProgram(program);\n\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\t\tvar err = gl.getProgramInfoLog(program);\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\tthrow new Error('GL program linking failed: ' + err);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction init() {\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tunpackProgram = initProgram(shaders.vertexStripe, shaders.fragmentStripe);\n\t\t\t\tunpackPositionLocation = gl.getAttribLocation(unpackProgram, 'aPosition');\n\n\t\t\t\tunpackTexturePositionBuffer = gl.createBuffer();\n\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t0, 0,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t1, 1\n\t\t\t\t]);\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\n\t\t\t\tunpackTexturePositionLocation = gl.getAttribLocation(unpackProgram, 'aTexturePosition');\n\t\t\t\tstripeLocation = gl.getUniformLocation(unpackProgram, 'uStripe');\n\t\t\t\tunpackTextureLocation = gl.getUniformLocation(unpackProgram, 'uTexture');\n\t\t\t}\n\t\t\tprogram = initProgram(shaders.vertex, shaders.fragment);\n\n\t\t\tbuf = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, rectangle, gl.STATIC_DRAW);\n\n\t\t\tpositionLocation = gl.getAttribLocation(program, 'aPosition');\n\t\t\tlumaPositionBuffer = gl.createBuffer();\n\t\t\tlumaPositionLocation = gl.getAttribLocation(program, 'aLumaPosition');\n\t\t\tchromaPositionBuffer = gl.createBuffer();\n\t\t\tchromaPositionLocation = gl.getAttribLocation(program, 'aChromaPosition');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object\n\t\t */\n\t\tself.drawFrame = function(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tvar formatUpdate = (!program || canvas.width !== format.displayWidth || canvas.height !== format.displayHeight);\n\t\t\tif (formatUpdate) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t\tself.clear();\n\t\t\t}\n\n\t\t\tif (!program) {\n\t\t\t\tinit();\n\t\t\t}\n\n\t\t\tif (formatUpdate) {\n\t\t\t\tvar setupTexturePosition = function(buffer, location, texWidth) {\n\t\t\t\t\t// Warning: assumes that the stride for Cb and Cr is the same size in output pixels\n\t\t\t\t\tvar textureX0 = format.cropLeft / texWidth;\n\t\t\t\t\tvar textureX1 = (format.cropLeft + format.cropWidth) / texWidth;\n\t\t\t\t\tvar textureY0 = (format.cropTop + format.cropHeight) / format.height;\n\t\t\t\t\tvar textureY1 = format.cropTop / format.height;\n\t\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t\ttextureX0, textureY0,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX1, textureY1\n\t\t\t\t\t]);\n\n\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\t\t\t\t};\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tlumaPositionBuffer,\n\t\t\t\t\tlumaPositionLocation,\n\t\t\t\t\tbuffer.y.stride);\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tchromaPositionBuffer,\n\t\t\t\t\tchromaPositionLocation,\n\t\t\t\t\tbuffer.u.stride * format.width / format.chromaWidth);\n\t\t\t}\n\n\t\t\t// Create or update the textures...\n\t\t\tuploadTexture('uTextureY', formatUpdate, buffer.y.stride, format.height, buffer.y.bytes);\n\t\t\tuploadTexture('uTextureCb', formatUpdate, buffer.u.stride, format.chromaHeight, buffer.u.bytes);\n\t\t\tuploadTexture('uTextureCr', formatUpdate, buffer.v.stride, format.chromaHeight, buffer.v.bytes);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\t// Unpack the textures after upload to avoid blocking on GPU\n\t\t\t\tunpackTexture('uTextureY', formatUpdate, buffer.y.stride, format.height);\n\t\t\t\tunpackTexture('uTextureCb', formatUpdate, buffer.u.stride, format.chromaHeight);\n\t\t\t\tunpackTexture('uTextureCr', formatUpdate, buffer.v.stride, format.chromaHeight);\n\t\t\t}\n\n\t\t\t// Set up the rectangle and draw it\n\t\t\tgl.useProgram(program);\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\n\t\t\tattachTexture('uTextureY', gl.TEXTURE0, 0);\n\t\t\tattachTexture('uTextureCb', gl.TEXTURE1, 1);\n\t\t\tattachTexture('uTextureCr', gl.TEXTURE2, 2);\n\n\t\t\t// Set up geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, lumaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(lumaPositionLocation);\n\t\t\tgl.vertexAttribPointer(lumaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, chromaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(chromaPositionLocation);\n\t\t\tgl.vertexAttribPointer(chromaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Aaaaand draw stuff.\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\t\t\tgl.clearColor(0.0, 0.0, 0.0, 0.0);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t};\n\n\t\tself.clear();\n\n\t\treturn self;\n\t}\n\n\t// Optional performance hack for Windows; luminance and alpha textures are\n\t// ssllooww to upload on some machines, so we pack into RGBA and unpack in\n\t// the shaders.\n\t//\n\t// Some browsers / GPUs seem to have no problem with this, others have\n\t// a huge impact in CPU doing the texture uploads.\n\t//\n\t// For instance on macOS 12.2 on a MacBook Pro 2018 with AMD GPU it\n\t// can real down at high res. This is partially compensated for by\n\t// improving the upload-vs-update behavior for the alpha textures.\n\t//\n\t// Currently keeping it off as of April 2022, but leaving it in so it\n\t// can be enabled if desired.\n\tWebGLFrameSink.stripe = false;\n\n\tWebGLFrameSink.contextForCanvas = function(canvas) {\n\t\tvar options = {\n\t\t\t// Don't trigger discrete GPU in multi-GPU systems\n\t\t\tpreferLowPowerToHighPerformance: true,\n\t\t\tpowerPreference: 'low-power',\n\t\t\t// Don't try to use software GL rendering!\n\t\t\tfailIfMajorPerformanceCaveat: true,\n\t\t\t// In case we need to capture the resulting output.\n\t\t\tpreserveDrawingBuffer: true\n\t\t};\n\t\treturn canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);\n\t};\n\n\t/**\n\t * Static function to check if WebGL will be available with appropriate features.\n\t *\n\t * @returns {boolean} - true if available\n\t */\n\tWebGLFrameSink.isAvailable = function() {\n\t\tvar canvas = document.createElement('canvas'),\n\t\t\tgl;\n\t\tcanvas.width = 1;\n\t\tcanvas.height = 1;\n\t\ttry {\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (gl) {\n\t\t\tvar register = gl.TEXTURE0,\n\t\t\t\twidth = 4,\n\t\t\t\theight = 4,\n\t\t\t\ttexture = gl.createTexture(),\n\t\t\t\tdata = new Uint8Array(width * height),\n\t\t\t\ttexWidth = WebGLFrameSink.stripe ? (width / 4) : width,\n\t\t\t\tformat = WebGLFrameSink.stripe ? gl.RGBA : gl.ALPHA,\n\t\t\t\tfilter = WebGLFrameSink.stripe ? gl.NEAREST : gl.LINEAR;\n\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n\t\t\tgl.texImage2D(\n\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t0, // mip level\n\t\t\t\tformat, // internal format\n\t\t\t\ttexWidth,\n\t\t\t\theight,\n\t\t\t\t0, // border\n\t\t\t\tformat, // format\n\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\tdata // data!\n\t\t\t);\n\n\t\t\tvar err = gl.getError();\n\t\t\tif (err) {\n\t\t\t\t// Doesn't support alpha textures?\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tWebGLFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = WebGLFrameSink;\n})();\n\n\n/***/ }),\n\n/***/ 9098:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/*\nCopyright (c) 2014-2019 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar depower = __webpack_require__(6117);\n\n\t/**\n\t * Basic YCbCr->RGB conversion\n\t *\n\t * @author Brion Vibber <brion@pobox.com>\n\t * @copyright 2014-2019\n\t * @license MIT-style\n\t *\n\t * @param {YUVFrame} buffer - input frame buffer\n\t * @param {Uint8ClampedArray} output - array to draw RGBA into\n\t * Assumes that the output array already has alpha channel set to opaque.\n\t */\n\tfunction convertYCbCr(buffer, output) {\n\t\tvar width = buffer.format.width | 0,\n\t\t\theight = buffer.format.height | 0,\n\t\t\thdec = depower(buffer.format.width / buffer.format.chromaWidth) | 0,\n\t\t\tvdec = depower(buffer.format.height / buffer.format.chromaHeight) | 0,\n\t\t\tbytesY = buffer.y.bytes,\n\t\t\tbytesCb = buffer.u.bytes,\n\t\t\tbytesCr = buffer.v.bytes,\n\t\t\tstrideY = buffer.y.stride | 0,\n\t\t\tstrideCb = buffer.u.stride | 0,\n\t\t\tstrideCr = buffer.v.stride | 0,\n\t\t\toutStride = width << 2,\n\t\t\tYPtr = 0, Y0Ptr = 0, Y1Ptr = 0,\n\t\t\tCbPtr = 0, CrPtr = 0,\n\t\t\toutPtr = 0, outPtr0 = 0, outPtr1 = 0,\n\t\t\tcolorCb = 0, colorCr = 0,\n\t\t\tmultY = 0, multCrR = 0, multCbCrG = 0, multCbB = 0,\n\t\t\tx = 0, y = 0, xdec = 0, ydec = 0;\n\n\t\tif (hdec == 1 && vdec == 1) {\n\t\t\t// Optimize for 4:2:0, which is most common\n\t\t\toutPtr0 = 0;\n\t\t\toutPtr1 = outStride;\n\t\t\tydec = 0;\n\t\t\tfor (y = 0; y < height; y += 2) {\n\t\t\t\tY0Ptr = y * strideY | 0;\n\t\t\t\tY1Ptr = Y0Ptr + strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\t\t\t\tfor (x = 0; x < width; x += 2) {\n\t\t\t\t\tcolorCb = bytesCb[CbPtr++] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr++] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\t\t\t\t}\n\t\t\t\toutPtr0 += outStride;\n\t\t\t\toutPtr1 += outStride;\n\t\t\t\tydec++;\n\t\t\t}\n\t\t} else {\n\t\t\toutPtr = 0;\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\txdec = 0;\n\t\t\t\tydec = y >> vdec;\n\t\t\t\tYPtr = y * strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\txdec = x >> hdec;\n\t\t\t\t\tcolorCb = bytesCb[CbPtr + xdec] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr + xdec] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[YPtr++] | 0;\n\t\t\t\t\toutput[outPtr    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmodule.exports = {\n\t\tconvertYCbCr: convertYCbCr\n\t};\n})();\n\n\n/***/ }),\n\n/***/ 6117:\n/***/ (function(module) {\n\n/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  /**\n   * Convert a ratio into a bit-shift count; for instance a ratio of 2\n   * becomes a bit-shift of 1, while a ratio of 1 is a bit-shift of 0.\n   *\n   * @author Brion Vibber <brion@pobox.com>\n   * @copyright 2016\n   * @license MIT-style\n   *\n   * @param {number} ratio - the integer ratio to convert.\n   * @returns {number} - number of bits to shift to multiply/divide by the ratio.\n   * @throws exception if given a non-power-of-two\n   */\n  function depower(ratio) {\n    var shiftCount = 0,\n      n = ratio >> 1;\n    while (n != 0) {\n      n = n >> 1;\n      shiftCount++\n    }\n    if (ratio !== (1 << shiftCount)) {\n      throw 'chroma plane dimensions must be power of 2 ratio to luma plane dimensions; got ' + ratio;\n    }\n    return shiftCount;\n  }\n\n  module.exports = depower;\n})();\n\n\n/***/ }),\n\n/***/ 6337:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  var FrameSink = __webpack_require__(3605),\n    SoftwareFrameSink = __webpack_require__(2333),\n    WebGLFrameSink = __webpack_require__(3935);\n\n  /**\n   * @typedef {Object} YUVCanvasOptions\n   * @property {boolean} webGL - Whether to use WebGL to draw to the canvas and accelerate color space conversion. If left out, defaults to auto-detect.\n   */\n\n  var YUVCanvas = {\n    FrameSink: FrameSink,\n\n    SoftwareFrameSink: SoftwareFrameSink,\n\n    WebGLFrameSink: WebGLFrameSink,\n\n    /**\n     * Attach a suitable FrameSink instance to an HTML5 canvas element.\n     *\n     * This will take over the drawing context of the canvas and may turn\n     * it into a WebGL 3d canvas if possible. Do not attempt to use the\n     * drawing context directly after this.\n     *\n     * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n     * @param {YUVCanvasOptions} options - map of options\n     * @returns {FrameSink} - instance of suitable subclass.\n     */\n    attach: function(canvas, options) {\n      options = options || {};\n      var webGL = ('webGL' in options) ? options.webGL : WebGLFrameSink.isAvailable();\n      if (webGL) {\n        return new WebGLFrameSink(canvas, options);\n      } else {\n        return new SoftwareFrameSink(canvas, options);\n      }\n    }\n  };\n\n  module.exports = YUVCanvas;\n})();\n\n\n/***/ })\n\n}]);"],"names":["self","push","module","exports","vertex","fragment","vertexStripe","fragmentStripe","FrameSink","canvas","options","prototype","drawFrame","buffer","clear","__unused_webpack_exports","__webpack_require__","YCbCr","SoftwareFrameSink","ctx","getContext","imageData","resampleCanvas","resampleContext","cropWidth","cropHeight","drawContext","format","width","displayWidth","height","displayHeight","initImageData","data","createImageData","pixelCount","i","convertYCbCr","resample","document","createElement","putImageData","cropLeft","cropTop","drawImage","clearRect","Object","create","shaders","WebGLFrameSink","program","unpackProgram","buf","positionLocation","unpackTexturePositionBuffer","unpackTexturePositionLocation","stripeLocation","unpackTextureLocation","lumaPositionBuffer","lumaPositionLocation","chromaPositionBuffer","chromaPositionLocation","gl","contextForCanvas","compileShader","type","source","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","err","getShaderInfoLog","deleteShader","rectangle","Float32Array","textures","framebuffers","stripes","createOrReuseTexture","name","formatUpdate","createTexture","uploadTexture","texture","activeTexture","TEXTURE0","stripe","uploadTemp","tempTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","texSubImage2D","stripeTexture","uploadStripe","buildStripe","out","Uint32Array","Uint8Array","LINEAR","ALPHA","unpackTexture","useProgram","fb","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE1","uniform1i","TEXTURE2","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","viewport","drawArrays","TRIANGLES","length","attachTexture","register","index","getUniformLocation","initProgram","vertexShaderSource","fragmentShaderSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","init","getAttribLocation","createBuffer","textureRectangle","bufferData","STATIC_DRAW","setupTexturePosition","location","texWidth","textureX0","textureX1","textureY0","textureY1","y","stride","u","chromaWidth","bytes","chromaHeight","v","clearColor","COLOR_BUFFER_BIT","preferLowPowerToHighPerformance","powerPreference","failIfMajorPerformanceCaveat","preserveDrawingBuffer","isAvailable","e","filter","getError","depower","output","hdec","vdec","bytesY","bytesCb","bytesCr","strideY","strideCb","strideCr","outStride","YPtr","Y0Ptr","Y1Ptr","CbPtr","CrPtr","outPtr","outPtr0","outPtr1","colorCb","colorCr","multY","multCrR","multCbCrG","multCbB","x","xdec","ydec","ratio","shiftCount","n","attach","webGL"],"sourceRoot":""}